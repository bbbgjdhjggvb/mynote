# 概述
索引是帮组mysql高效获取数据的 _数据结构（有序）_

## 索引结构
各个引擎支持的索引
![[Pasted image 20241127170020.png]]
## B+Tree
b-tree
![[Pasted image 20241127170534.png]]
b+tree
所有元素都在叶子节点
叶子组之间双链，叶子之间单链
![[Pasted image 20241127171744.png]]
## Hash
![[Pasted image 20241127203637.png]]
特点：
1. 只能进行等值匹配，不支持范围查询（between， <, >）
2. 无法利用索引完成排序
3. 查询效率高
存储引擎：
Memory支持，而InnoDB中具有自适应hash供能

## R-tree

## Full-text

# 索引的分类
![[Pasted image 20241127204259.png]]
InnoDB中的索引分类
![[Pasted image 20241127204441.png]]
聚集索引选取规则：
1. 主键索引就是聚集索引
2. 如果没有主键，将会使用第一个唯一索引作为聚集索引
3. 没有主键也没有唯一索引，InnoDB会自动生成一个rowid作为隐藏的聚集索引
聚集索引结构
![[Pasted image 20241127204837.png]]
1. 叶子节点是一行的全部内容
二级索引结构
![[Pasted image 20241127204938.png]]
1. 叶子节点的内容是主键
2. 回表查询：先根据二级索引找到主键，再根据聚集索引找到全部内容

# 创建索引
## 创建表格的时候直接指定索引
```sql
CREATE TABLE articles (
	id INT PRIMARY KEY AUTO_INCREMENT,
	title Varchar(20),
	context TEXT,
	-- 为tile和content创建全文索引
	FULLTEXT INDEX idx_article_text(title, content)
)ENGINE = InnoDB;
```
- FULLTEXT INDEX指全文索引
- UNIQUE INDEX指唯一索引
- 只要是主键就会自动创建主键索引
- INDEX：普通索引

## 已存在的表通过ALTER语句添加
```sql
ALTER TABLE articles
ADD FULLTEXT INDEX idx_article_text(title, content);
```

# 查找索引
```sql
SHOW INDEX FROM table
```

# 删除索引
```sql
DROP INDEX index_name ON table
```

# 索引的出发点
## 全文索引(MATCH ... AGAINST)
### 自然语言模式
默认的处理方式，用于搜索包含“查询词”的记录，返回结果按照相关性进行排列
```sql
SELECT xxx
FROM table_name
WHERE MATCH(title, content) AGAINST('查询词1 查询词2'
[IN NATURAL LANGUANGE MODE]);
```

### 布尔模式
支持通过运算符来精确控制检索条件，适合复杂查询，（如必须包含“A”，必须排除“B”）
```sql
SELECT *
FROM table_name
WHERE MATCH(title, content)
AGAINST('+mysql -orcale' IN BOOLEAN MODE)
```
- +：必须包含
- -：必须排除
- \*：前缀匹配`mysql*`
- ""：短语匹配`"mysql index"`
# SQL性能分析
1. 查看语句执行频率`SHOW GLOBAL STATUS LIKE 'Com_______'`
	1. 7个下划线
2. 慢查询日志：定位哪些sql中执行效率比较低。看哪些sql指令执行时间小于预设时间（默认10秒）
	1. 默认没有开启，查看开启`SHOW VARIABLES LIKE 'slow_query_log'`
	2. 开启：配置文件`/etc/my.cnf` 或者对应文件夹中的`server.cnf`和`client.cnf`，在server中修改
		1. `slow_query_log = 1`
		2. `long_query_time = 2`
	3. 默认路径`/var/lib/mysql/localhost-slow.log`
	4. 最终文件后面10行的内容`tail -f file -n linenum`
3. profile详情
	1. 查看是否拥有profile `SELECT @@have_profiling`
	2. 查看是否有开`SELECT @@profiling`
	3. 开启profile `SET profiling = 1`
	4. 用`show profiles`：查看会话中所有执行过的指令的运行时间
	5. 查看`SHOW PROFILE FOR QUERY id`：查看各个阶段指令运行时间
4. explain执行计划
	1. 使用：在任意一条SELECT 语句前加上explain就行
	2. ![[Pasted image 20241127214849.png]]
		1. id：id值越大，越先执行，id有可能相同，相同就是从上往下
		2. select type：查询的类型
			1. sample
			2. PRIMARY
			3. UNION
			4. SUBQUERY
		3. type：连接类型，性能由好到差的连接类型为
			1. NULL
			2. system
			3. const：唯一索引
			4. eq_ref
			5. ref：非唯一索引
			6. range
			7. index：
			8. all：全表扫描
		4. possible key：可能使用到的索引
		5. key：使用到的索引
		6. row：表示查询的行数
		7. filtered：查询占读取的百分比
# 最左前缀法则
联合索引要遵守最左前缀法则，从索引的最左列开始，不跳过索引的列。如果跳过某一列，后面的字段索引失效。_必须存在和放的位置没有关系_ 。
假如联合索引用到字段id, name, num
```sql
SELECT * FROM table WHERE id = x and name = x and num =x -- 有效

SELECT * FROM table WHERE id = x and name = x -- 有效

SELECT * FROM table WHERE name = x and num =x
-- 索引失效因为不能匹配到索引最左前缀

SELECT * FROM table WHERE id = x and num =x
-- id索引有效，num索引失效，因为id是索引列前缀，num不是
```
# 索引失效的其他情况
## 范围查询
联合索引中，出现范围查询，范围查询右侧的列索引失效
```sql
SELECT * FROM table WHERE id = x and name > x and num =x
-- num部分到索引将会失效
```
## 索引列运算或函数操作
 不要在索引列上进行运算操作，索引将失效
```sql
SELECT * FROM table_name WHERE price * 0.8 < 100;
```
## 隐式类型转换
若索引列类型和查询条件中的类型不匹配，Mysql会自动利用CAST函数对数据进行操作，从而导致索引失效
```sql
SELECT * FROM table_name WHERE phone = '110'; -- 索引有效
SELECT * FROM table_name WHERE phone = 110; -- 索引失效
```
## 模糊查询
B+树索引通过前缀有序性快速定位到数据，若查询中使用百分号模糊了前缀，会导致索引失效。
如果后面模糊，索引有效。如果前面模糊，索引无效。
```sql
WHERE name = "li%" -- 有效
WHERE name = "%li" -- 失效
```

## or连接的条件
OR连接到多个条件中，如果有一个不是索引列也会导致索引失效
## 数据分布的影响
mysql评估全表扫描比索引快，索引会无效。评估数据量。
### 使用了不等于，否定操作符
使用 !=，<>，NOT IN，NOT EXISTS，NOT LIKE会导致优化器认为查询结果集比较大，全表扫描比可能会比索引快，索引失效

## SQL提示
多个索引，告诉使用哪一个索引，有可能被拒绝。
```
EXPLAIN select * from table [use index(index_name)] WHERE xxx;
                            [ignore index(index_name)]
                            [force index(index_name)]：强制使用
```
# 覆盖索引
查询使用了索引，查询返回到列数据中不存在存在不属于索引的列，这样就会不会触发回表查询，减少使用`SELECT *`
# 前缀索引
前缀索引是针对字符串类型的一种索引优化方式，它通过街区字符串的前N个字符来创建索引而不是利用整个字符串创建索引，减少索引占用空间。
## 前缀索引创建语法
```sql
ALTER TABLE table_name ADD INDEX idx_qianzui (列名(n))
```

## 确定N
通过计算不同前缀长度的区分度，选择区分度接近全列的n
```sql
-- 计算全列区分度
SELECT COUNT(DISTINCT column) / COUNT(*) 
AS full_distinct_ratio 
FROM table_name

-- 计算前N个字符的区分度
SELECT COUNt(DISTINCT LEFT(column, n)) / count(*)
AS n_distinct_ratio
FROM table_name
```

## 前缀匹配的局限性
- 不是覆盖索引，必定会触发回表查询，因为索引只存储前几个字符
- 不支持后缀和中缀匹配