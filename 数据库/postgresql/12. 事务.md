### 开启事务
```
BEGIN; -- 或者 START TRANSACTION;
```

### 提交事务
```
COMMIT; -- 或者 END TRANSACTION;
```

### 回滚事务
```
ROLLBACK;
```

# 事务会带来的问题
## 脏读
读取了未提交的数据
### PG中解决脏读的方法
xmin：对于数据行，创建该数据行的事务ID
xmax：对数据行执行修改或删除操作的事务ID
```
T1: INSERT INTO testtable VALUES(1), (2)....;
此时所有的数据xmin为1，xmax为0

T2: select * from testtable;
在T2执行的过程中T3事务启动，执行了修改操作

T3: update testtable set value=100where id = 20;
执行T3操作后原本20对应的行的xmax会被修改为3，xmin为1，并插入新的数据行100，表示被事务2修改了，当T2执行到20的时候发现xmax为在T2事务启动之后的事务T3，并且T3还未提交所以该数据对T2不可见，当执行到100时，xmin为3，大于当前事务T2的id，所以也不可见

有可能T3已经读到了value为20的数据，对于新数据100一定是读不到的

这样带来了一个问题，多次读取value为20的值时，第一次读到了，第二次读不到，出现不可重复读
```
## 不可重复读
在同一个事务中多次读取的结果不一致，注意是在同一个事务中
### PG中解决不可重复读的方法
假设事务 T1 在开始时创建了快照 S1，在事务 T1 执行过程中，事务 T2 对数据进行了修改并提交。当事务 T1 再次读取数据时，由于它依据的是开始时创建的快照 S1，事务 T2 提交后产生的新数据版本的 xmin 不在快照 S1 的已提交事务 ID 列表中（因为 T2 是在 T1 开始后提交的），所以事务 T1 仍然只能看到事务 T2 修改之前的数据版本，从而保证了在同一事务内多次读取数据的结果是一致的，避免了不可重复读。

## 幻读
同一个事务中，多次执行同一个查询，返回的结果行数不一致


### 设置事务的隔离等级
```
BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;

```
1. `READ UNCOMMITTED`
2. `READ COMMIT`
	1. 默认隔离级别
3. `REPEARABLE READ`
	1. 事务在读取一次后，其他事务的提交不会影响接下来的处理
	2. pg这一隔离等级下不会出现幻读，这点和mysql不一样。
4. `Serializable`
	1. 序列化，串行执行
