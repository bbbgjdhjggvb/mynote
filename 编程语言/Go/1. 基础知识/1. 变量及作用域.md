#  显示声明
```go
var varName int = 10;
var varName = 10;
var varName int;
```

# 声明并定义
```go
func foo(){
	x := 42
}
```
1. 只能在函数内部
2. 不能在函数外部使用

# 批量声明
```go
var (
	a int
	b int
)
```

# 包级作用域
```go
var varName = 10
func main(){
}
```
1. 变量名字首字母小写表示不可跨包使用
2. 变量名字首字母大写表示可以跨包使用

# 基本数据类型
```go
整数类型
int, int8, int16, int32, int64
uint, uint8, ... , uint64, uintptr
uintx
浮点类型
float32, float64
布尔类型
bool
字符类型
byte ：用来表示ASCII字符（等价于uint8）
rune ：用来表示Unicode字符（等价于uint32）
字符串类型
string
复数
complex64, complex128
```

# 没有明确初始化的变量会被赋予零值
1. 数值类型为0
2. 布尔类型为false
3. 字符串为""(空字符串)

# 类型转换
`T(v)`将值v转换为T类型

```go
var i int = 42
var f float64 = float64(i)
var u uint = uint(f)
```

# 类型推断
在声明一个变量但是不指定它的类型的时候，具体的类型会根据右值推断出来
```go
i := 42           // int
f := 3.142        // float64
g := 0.867 + 0.5i // complex128
```

# 常量类型
常量的声明和变量的声明类似，但是使用const关键字，*常量不能使用 := 进行声明*
```go
const Pi = 3.14 
```



# Go逃逸分析、构造函数和复合字面
GO会进行逃逸分析， 如果编译器检测到局部变量的指针被返回时，会自动将指针指向的变量分配到堆上，而不是栈上，从而避免内存泄漏。所以如下代码正确。当返回一个局部变量时，会自动调用new将变量分配到堆上。
```go
return &logrusLogger{
	entry: logrus.NewEntry(log),
}
```

```go
func NewFile(fd int, name string) *File {
	if fd < 0 {
		return nil
	}
	f := File{fd, name, nil, 0}
	return &f
}
```

