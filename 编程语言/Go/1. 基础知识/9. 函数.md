# func main(){}
系统的入口函数

# 自定义函数
```go
func fooname(var0 type, var1 type) (returnType0, returnType1) {
}

func fooname(var0 type) returnType {
}
```
1. 多个返回值，需要用到括号
2. go没有默认参数传入
3. 名字首字母大写，对包封闭

# 值传递和引用传递
1. 基本数据类型通过值传递
2. 复杂数据类型通过引用传递

# defer关键字
defer关键字会将函数推迟到外层函数返回*之后*执行
```go
func main() {
	defer fmt.Println("world")
	defer fmt.Println("!")
	
	fmt.Println("hello")
}

-----out------
hello
!
world
-----out------

func main() {
	i := 0
    defer fmt.Println(i)
    i++
    return
}
-----out------
0
-----out------

// i的值在defer语句的所在行已经确定好了

func c() (i int) {
    defer func() { i++ }()
    return 1
}

```
1. defer后进先出，有一个栈管理defer语句
2. defer的函数的参数会立即进行运算
3. defer可以读取外部函数的值并进行赋值操作()

# init函数
1. 作用：引入包时进行初始化
2. 一个包允许有多个init函数
3. 执行顺序
	1. 变量初始化
	2. init函数执行
	3. 多个init函数按顺序执行
# 函数对象
```go
func compute(fn func(float64, float64) float64) float64 {
	return fn(3, 4)
}
```
1. `func(float64, float64) float64是一个函数类型
# 匿名函数和闭包
```go
package main

import "fmt"

func adder() func(int) int {
	sum := 0
	return func(x int) int {
		sum += x
		return sum
	}
}

func main() {
	pos, neg := adder(), adder()
	for i := 0; i < 10; i++ {
		fmt.Println(
			pos(i),
			neg(-2*i),
		)
	}
}

----out----
0 0
1 -2
3 -6
6 -12
10 -20
15 -30
21 -42
28 -56
36 -72
45 -90
----out----
```
1. sum只进行一次初始化，但是执行的过程中一直在被累加