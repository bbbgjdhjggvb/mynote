Go标准库中`container/heap`包提供了堆的接口，通过实现这个接口可以构建优先队列
# 实现注意点
## 必须实现heap.Interface接口
- `Len() int`
- `Less(i, j, int)`
	- 返回`x < x`，是最小堆
	- 返回`x > x`，是最大堆
- `Swap(i, j int)`
- `Push(x any)`
- `Pop() any`
## Push和Pop需要用指针作为接收者
因为Push和Pop函数需要修改底层数据结构

下面例子中实现的是最小堆
```go
package main

import (
	"fmt"
	"container/heap"
)

type Item struct{
	Value int
	Priority int
	Index int
}

type PriorityQueue []*Item

func (p PriorityQueue)Len() int{
	return len(p)
}

func (p PriorityQueue) Less(i, j int) bool{
	return p[i].Priority < p[j].Priority
}

func (p PriorityQueue) Swap(i, j int){
	p[i],p[j]=p[j],p[i]
	p[i].Index = i
	p[j].Index = j
}

func (p *PriorityQueue) Push(x any){
	n := len(*p)
	item := x.(*Item)
	item.Index = n
	*p = append(*p, item)
}

func (p *PriorityQueue) Pop() any{
	old := *p
	n := len(old)
	item := old[n-1]
	item.Index = -1 
	*p = old[0:n-1]
	return item
}

func main(){
	pq := make(PriorityQueue, 0)
	heap.Init(&pq)

	heap.Push(&pq, &Item{1,1,0})
	heap.Push(&pq, &Item{3,3,0})
	heap.Push(&pq, &Item{2,2,0})

	for pq.Len() > 0{
		item := heap.Pop(&pq).(*Item)
		fmt.Printf("value: %d, priority: %d\n", item.Priority, item.Value)
	}
}
```