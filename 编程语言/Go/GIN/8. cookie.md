cookie是由服务端生成的文本，在发送回浏览器的响应报文中添加`Set Cookie`字段，然后浏览器自动存储这些数据，并在后续发送的请求报文中添加`cookie`字段

# 服务器发送的响应报文中Set-cookie字段
```
Set-Cookie: <name>=<value>; Expires=<date>; Max-Age=<seconds>; Domain=<domain>; Path=<path>; Secure; HttpOnly; SameSite=<policy>
```
1. name：键值对，如token=98hda9bfldbaul
2. Expires：过期时间，如Expires=Wed, 21 Oct 2025 09:12:12
3. Max-Age：设置相对的过期时间(秒)，如Max-Age=254198
4. Domain：指定哪些域名可以访问，Domain=.example.com
5. Path：指定URL路径作用域
6. Secure：仅通过HTTPS传输
7. HttpOnly：禁止JavaScript访问
8. Same Site：控制跨站请求发送
9. Priority：低存储空间时优先级

# Gin框架设置cookie
```go
func xxx(c *gin.Context, token string, maxage int){
	c.SetCookie(
		"x-token", // 键名
		token,     // 键值
		maxage,    // 有效时长
		"/",       // 路径
		"",        // 域名
		true,      // Secure
		true,      // httponly
	)
}
```
如果domain为*example.com*，path为 */* ，那么如下URL发送请求自动填充Cookie
1. https://example.com
2. https://example.com/api
3. https://example.com/api/login
注意如果domian为 *.example.com*，表示匹配所有子域名
4. https://www.example.com

# Secure为true
## 会填充cookie的情景
跨站表单提交会自动填充cookie
```html
<!-- 在其他网站的表单 -->
<form action="https://example.com/login" method="GET">
  <input type="submit" value="提交">
</form>
```

## 不会填充cookie的情景
JavaScript使用AJAX/Fetch请求，不会自动填充cookie
```javascript
// 在其他网站运行的 JavaScript
fetch('https://example.com/api', {
  method: 'POST',
  body: JSON.stringify({ data: 'test' })
})
```

跨站非导航 POST 请求
```html
<!-- 在其他网站的表单 -->
<form action="https://example.com/submit" method="POST">
  <input type="submit" value="提交">
</form>
```