# Stringer接口
```go
type Stringer interface {
    String() string
}

type Person struct {
	Name string
	Age  int
}

func (p Person) String() string {
	return fmt.Sprintf("%v (%v years)", p.Name, p.Age)
}
```
`Stringer` 是一个可以用字符串描述自己的类型

# error接口
```go
type error interface {
    Error() string
}

// 自定义Error类型实现Error函数
type MyError struct {
	When time.Time
	What string
}

func (e *MyError) Error() string {
	return fmt.Sprintf("at %v, %s",
		e.When, e.What)
}

func run() error {
	return &MyError{
		time.Now(),
		"it didn't work",
	}
}

// fmt打印的时候就会调用Error函数
func main() {
	if err := run(); err != nil {
		fmt.Println(err)
	}
}
```

# Readers接口
用数据填充给定的字节切片，并返回填充的个数和错误，并在遇到数据流的结尾时，返回io.EOF
```go
func (T) Read(b []byte) (n int, err error)

// strings包定义的NewReader对象的Read函数
func main() {
	r := strings.NewReader("Hello, Reader!")

	b := make([]byte, 8)
	for {
		n, err := r.Read(b)
		fmt.Printf("n = %v err = %v b = %v\n", n, err, b)
		fmt.Printf("b[:n] = %q\n", b[:n])
		if err == io.EOF {
			break
		}
	}
}
```

# sort.Interface接口
实现该接口可以调用sort包中的sort函数对切片中元素进行排序，正常实现是升序

## sort.Interface接口的定义
```go
type Interface interface {
    // Len 返回集合中的元素数量
    Len() int
    
    // Less 报告索引i的元素是否应该排在索引j的元素之前
    Less(i, j int) bool
    
    // Swap 交换索引i和j的两个元素
    Swap(i, j int)
}
```

## sort.Interface接口的使用步骤
```go
type Person struct{
	Name string
	age int
}

// 实现接口
type personArrayByAge []Person

func (a personArrayByAge) Len(){
	return len(a)
}

func (a personArrayByAge) Less(i, j int)bool{
	return a[i].age < a[j].age
}

func (a personArrayByAge) Swap(i, j int) {
	a[i], a[j] = a[j], a[i]
}

// 使用sort.Sort进行排序
func main() {
    people := []Person{
        {"Bob", 31},
        {"John", 42},
        {"Michael", 17},
        {"Jenny", 26},
    }
    
    // 转换为ByAge类型并排序
    sort.Sort(ByAge(people))
    
    fmt.Println(people)
    // 输出: [{Michael 17} {Jenny 26} {Bob 31} {John 42}]
}
```