go中没有面向对象的继承概念，go通过组合和接口实现继承和多态

# 继承：通过匿名成员实现
在go中没有继承的概念，而是使用了内嵌结构体的方式，这种方式更加倾向于组合。内部结构体定义的方法，外部结构题对象可以直接使用，*但是该方法的接受对象仍然是内部结构体*
```go
// 定义
type Class0 struct{
	c0_var0 int
}

type Class1 struct{
	Class0 //匿名成员
	c1_var0 int
}

// 实现
c1 = Class1{
		Class0: Class0{12},
		c1_var0: 134719
	}
```

# 接口：必须实现的函数
```go
// 定义接口
type speakable interface{
	Speak() string
	hello() string
}

// 接口组合
type hello interface{
	speakable
}

// 实现接口：
// 隐式实现：无需显示声明实现接口，只需方法名字匹配
```

# 多态：利用接口实现
```go
type Shape interface{
	Area() float64
}

type Circle struct{
	r int32
}

func (this *Circle) Area() float64 {
	return 3.14
}

type Square struct{
	l int
}

func(this *Square) Area() float 64{
	return 944
}

func PrintArea(s Shape){

}

func main(){
	shapes := []Shape{
		Circle{r: 5},
		Square{l: 4}
	}

	for _, shape := range shapes{
		PrintArea(shape)
	}
}
```

# 接受者为对象副本还是指针
```go
package main

import (
	"fmt"
	"math"
)

type Abser interface {
	Abs() float64
}

func main() {
	var a Abser
	f := MyFloat(-math.Sqrt2)
	v := Vertex{3, 4}

	a = f  // a MyFloat 实现了 Abser
	a = &v // a *Vertex 实现了 Abser

	// 下面一行，v 是一个 Vertex（而不是 *Vertex）
	// 所以没有实现 Abser。
	a = v // 报错

	fmt.Println(a.Abs())
}

type MyFloat float64

func (f MyFloat) Abs() float64 {
	if f < 0 {
		return float64(-f)
	}
	return float64(f)
}

type Vertex struct {
	X, Y float64
}

func (v *Vertex) Abs() float64 {
	return math.Sqrt(v.X*v.X + v.Y*v.Y)
}
```

# 接口的内嵌，实现接口的继承
```go
type A interface{

}


type B interface{

}

type C interface{
	A
	B
}
```

# 底层对象为nil对接口
不会出现空指针异常调用接口函数返回nil
## 为nil对接口调用接口函数就会报错
# 空接口和泛型
定义了0个方法对接口就是空接口
所有的类都隐式实现了空接口，因为空接口没有任何函数
## 类型断言
提供了访问接口底层对象的方法
```go
// 安全类型断言，如果断言成功，ok为true；如果断言失败，ok为false，t为T的零值，不会发生panic
var i interface{} = xxx
t, ok = i.(T)
```

## 类型选择
```go
func printType(v interface{}){
	switch v.(type) {
		case int:
			xxx
		case string:
			xxxx
		case default:
			// 没有匹配
			xxx
	}
}
```

## 指针断言
```go
type Cat struct{}
var a interface{} = &Cat{}  // 存储的是指针
cat1 := a.(Cat)    // panic: interface conversion: interface {} is *main.Cat, not main.Cat
cat2 := a.(*Cat)   // 正确
```