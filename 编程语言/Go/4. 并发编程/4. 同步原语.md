# 使用`-race`检测竞争条件
```
go run -race main.go
go build -race main.go
```

# 互斥锁：最基本的同步方式
- `sync.Mutex`：保护一个临界区
- `lock`方法：协程获取锁
- `unlock`方法：协程释放锁
```go
package main

import (
	"fmt"
	"sync"
)

var mu sync.Mutex

func main() {
	counter := 0
	var wg sync.WaitGroup

	for i := 0; i < 10000; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			mu.Lock()
			counter++
			mu.Unlock()
		}()
	}

	wg.Wait()
	fmt.Println(counter)
}
```

# 读写锁
- `sync.RWMutex`
## 读写锁的核心机制
- 读与读不互斥：允许多个goroutinue进行读操作
- 读与写互斥：当有读锁时，任何写操作都必须等待所有读锁释放，反之，当有写锁时，任何读操作都必须等待所有写锁释放
- 写与写互斥：同一时间只允许一个写操作

## 重要函数
- `Lock()`：获取写锁
- `Unlock()`：释放写锁
- `RLock()`：获取读锁
- `RUnlock()`：释放读锁

# WaitGroup
`sync.WaitGroup`：在GO中，当在main函数中启动多个goroutine，主goroutine不会等待它，会继续执行自己的代码，执行完后，真个程序就会退出，无论其他goroutine是否执行完毕
WaitGroup就是为了解决这个问题

## 工作原理和函数
- `Add(2)`：让计数器增加2，增加任务总数
- `Done()`：让计数器减少1
- `Wait()`：阻塞当前协程，直到计数器为0
如果计数器变化负数为引发panic

# Sync.once
`sync.once`：确保函数在整个程序的声明周期内只执行一次
## sync.Once对象的Do()函数
- 该函数的参数是一个函数
- 保证仅执行一次
- 并发安全：在多个协程的环境中，可以调用同一个sync.Once对象实例的do函数
- 阻塞等待：如果一个go程正在执行Do方法中传入的函数f，此时其他go程也调用了同一个sync.Once实例的Do方法，那么这些后面调用的会被阻塞，直到函数f执行完毕
- panic安全：如果第一次调用Do时，传入的函数f发生panic，sync.Once会认为这次初始化没有成功，后续对Do的调用会再次尝试执行函数f

