# 概念
1. 用于协调不同线程之间的通信和同步
2. 类型化的通信队列
3. 加锁容易出错，管道通过通信隐式同步，更加安全
4. 通过信道操作符号 <-来发送或者接受信息
5. 带有*特定类型*的管道

# 创建管道
```go
ch := make(chan int) 'int 是要传输的数据类型'
```

# 使用管道
```go
ch <- 4 '向管道内发送数据'

x := <- ch '从管道中接收数据而'

func sum(s []int, c chan int) {
	sum := 0
	for _, v := range s {
		sum += v
	}
	c <- sum // 发送 sum 到 c
}

func main() {
	s := []int{7, 2, 8, -9, 4, 0}

	c := make(chan int)
	go sum(s[:len(s)/2], c)
	go sum(s[len(s)/2:], c)
	x, y := <-c, <-c // 从 c 接收

	fmt.Println(x, y, x+y)
}
```
1. x不一定是数组的前半部份，采用先到先得机制，但是都会在接受代码处阻塞

# 带缓冲的信道
当信道被填满，向其发送数据会被阻塞，当信道为空，接受方会阻塞
```go
ch := make(chan int, 5) '缓冲容量为5的管道'
```
#  关闭管道
发送者可以关闭信道，表示没有新的东西要发送了，接受者可以判断信道是否被关闭
```go
close(ch)     // 发送者

v, ok <- ch   // 接受者
```
`for i := range c`可以不断从信道中接受值，直到信道被关闭
1. 只能由发送者关闭信道，向一个关闭的信道发送信息会引发panic

# select等待多个通信操作
select语句会阻塞直到某个分支可以执行，当多个分支都准备好时，会随机选择分支
```go
func fibonacci(c, quit chan int) {
	x, y := 0, 1
	for {
		select {
		case c <- x:
			x, y = y, x+y
		case <-quit: 
			// 若没有向quit发送信息，接收方阻塞，不会被选择
			fmt.Println("quit")
			return
		}
		case default:
			// 默认选择，在所有分支都阻塞的时候选择
	}
}
```
### 生产者，消费者模式
```go
'chan<-：指定发送数据到管道'
func producer(ch chan<- int) {
	for i := 0; i < 5; i++{
		ch <- i
	}
	close(ch)
}

'<-chan：指定从管道中读取'
func consumer(ch <-chan int) {
	for num := range ch{ '循环读取直到管道关闭'
		
	}
}

func main(){
	ch := make(chan, int)
	go producer(ch)
	consumer(ch)
}
```

### select语句，处理多管道
```go
select {
case v := <- ch1:
	xxxx
case v := <- ch2
	xxxx
default:
	fmt.Println("No data")
}
```
1. 每个case必须是管道操作
2. 当每个case都就绪时，随机选取
3. 无`default`，若所有case均未就绪，select阻塞，直到就绪
4. 有`default`，若没有case就绪，执行default

### select超时处理
```go
select {
	case v := <- ch1:
		xxx
	case <- time.After(2 * time.second):
		xxx
}
```

### select循环监听
```
for {
	case v1 := <- ch1:
		xxxx
	case V2 := <- ch2:
		xxxx
	case <- quitch:
		return
}
```
### select+time.Ticker定期执行任务
```go
tricker := time.NewTicker(1 * time.Minute)
defer tricker.Stop()

for {
	select{
		case <-ticker.C:
			xxxx
	}
}
```