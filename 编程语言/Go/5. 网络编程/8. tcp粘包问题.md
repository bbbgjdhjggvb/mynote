# 问题
客户端多次调用write函数，发送多个数据包，服务端调用了一次read函数，接收数据，发现接收到的数据是多个数据包粘在一起的、更大的数据包

# 原因
- TCP是面向字节流的协议，它不关心发送的数据是什么格式，它只保证字节的顺序和正确性
- Nagle算法：为流提高网络效率，TCP默认开发Nagle算法，这个算法会把发送方段时间内产生的多个小数据包缓存起来，合成一个大的数据包再发送出去
- 接收方缓冲区：接收方先把数据放入一个接收缓冲区，再从缓冲区中读取数据

# 解决方法
## 使用特殊分隔符
在每条消息的末尾添加一个特殊的分隔符，这个分隔符不能在正文中出现。
```go
bufio.NewReader(conn).ReadString('\n')
```

## 长度作为消息头
客户端对长度信息进行编码
```go
func encode(strmsg string) []byte {
	len := uint32(len(strmsg))
	pkg := make([]byte, 4+len)
	binary.BigEndian.PutUint32(pkg[:4], len)
	copy(pkg[4:], []byte(strmsg))
	return pkg
}
```
- BIgEndian表示大端编码
- copy函数

服务端对信息进行解码
```go
func decode(conn net.Conn) (string, error) {
	header := make([]byte, 4)
	_, err := io.ReadFull(conn, header)
	if err != nil {
		return "", err
	}

	bodylength := binary.BigEndian.Uint32(header)
	body := make([]byte, bodylength)
	_, err = io.ReadFull(conn, body)
	if err != nil {
		return "", err
	}
	return string(body), nil
}
```

### io.ReadFull函数
这个函数通常会用来处理二进制协议和固定大小的数据结构，其核心概念是*要么全部，要么没有*，这个函数会尝试将缓冲区给填满。如果正常读取返回错误`io.EOF`、如果读取没有充满，返回错误`io.ErrUnexpectedEOF`
