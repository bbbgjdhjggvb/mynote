# 地址解析函数
```go
func ResolveTCPAddr(network, addr string) (*TCPAddr, error)
```
## TCPAddr结构
```go
type TCPAddr struct{
	IP net.IP
	Port int
	Zone string // ipv6 区域标识
}
```
函数作用：
- 地址分解：分离出端口和域名/IP地址
- *DNS解析*：
```go
// 解析域名
addr, _ := net.ResolveTCPAddr("tcp", "google.com:80")
fmt.Println(addr.IP) // 输出：216.58.200.14（实际IP可能变化）
```
- 端口转换：将服务名转换为数值
```go
addr, _ := net.ResolveTCPAddr("tcp", "localhost:http")
fmt.Println(addr.Port) // 输出：80
```
参数：
- network：网络类型tcp、tcp4、tcp6

# 服务器监听函数
```go
func Listen(network, address string)(Listener, error)

func ListenTCP(network string, laddr *TCPAddr)(*TCPListener, error)
```
## 二者区别
- Listen函数返回的是*通用的*Listener接口，提供基础的函数Accept、Close、Addr
- ListenTCP返回的是实现了Listener接口的类型，提供功能更加丰富的函数AcceptTCP、SetDeadline
- 注意Listener是对象，TCPListener是指针

# 服务器接收函数
```go
func(l *Listener) Accept()(Conn, error)
func (l *TcpListener) Accept()(Conn, error)
func (l *TcpListener) AcceptTCP()(*TCPConn, error)
```
## TCPConn
TCPConn相比较于Conn，提供了许多控制TCP连接的方法
### 设置tcp参数
```go
// TCP Keep-Alive
func (c *TCPConn) SetKeepAlive(keepalive bool) error
func (c *TCPConn) SetKeepAlivePeriod(d time.Duration) error

// 设置挥手选项
func (c *TCPConn) SetLinger(sec int) error

// 半关闭连接
func(c *TCPConn) CloseRead()
func(c *TCPConn) CLoseWrite()
```
- SetKeepAlive函数启动后：操作系统会在连续空闲一段时间后，自动发送探测包来检查对方是否可达
- SetKeepAlivePeriod函数可以设置发送周期
- SetLinger函数sec>=0表示Close方法会等待指定时间，让所有待发送的数据发送出去后再关闭，sec<0表示立即关闭
- CloseRead函数关闭读取端，之后任何read操作都会导致错误

### 设置Deadline
当一个网络连接的对端没有响应、网络出现问题或者数据传输缓慢时，Read或者Write操作可能会永久阻塞，导致goroutinue被挂起，无法继续执行
```go
func (c *TCPConn) SetDeadline(t time.Time) error
func (c *TCPConn) SetReadDeadline(t time.Time) error
func (c *TCPConn) SetWriteDeadline(t time.Time) error
```
- 参数t是*截止时间*，而不是时间段
# 客户端连接函数
```go
func Dial(network, address string)(Conn, error)

func DialTCP(network string, laddr, raddr *TCPAddr) (*TCPConn, error)

func DialTimeout(network, address string, time time.Duration)(Conn, error)
```

# 数据读写
```go
// 通用 Conn 方法
func (c Conn) Read(b []byte) (n int, err error)
func (c Conn) Write(b []byte) (n int, err error)
```

## 读取数据
```go
func ProcessTcpConn(conn *net.TCPConn) {
	defer conn.Close()
	remoteAddr := conn.RemoteAddr()
	if remoteTcpAddr, ok := remoteAddr.(*net.TCPAddr); ok {
		msg := make([]byte, 1024)
		for {
			len, err := conn.Read(msg)
			if err != nil {
				if err == io.EOF {
					fmt.Println("Client %v close connection normally\n", remoteTcpAddr.IP)
				} else {
					fmt.Println("ERROR: ", err)
				}
				return
			}

			if len > 0 {
				fmt.Printf("Client %v: %v", remoteTcpAddr.IP, string(msg[:len]))
			}
		}
	}
}
```
### 出现io.EOF的情况
- TCP连接的一方调用了Close函数

# 连接关闭函数
```go
func (c *TCPConn) Close() error
func (l *TCPListener) Close() error
```

# 从连接中获取远端的IP地址
利用`conn.RemoteAddr()`方法，该方法是net.Conn接口的一个方法，返回`net.Addr`接口类型，然后进行类型断言，将net.Addr断言为net.TcpAddr类型，然后访问ip
```go
addr := 
```
# TCP服务端程序的处理流程
1. 监听端口
2. 接收客户端请求建立连接
3. 创建goroutine处理连接

```go
func process(conn net.Conn){

}

func main(){
	// 监听端口
	listen, err := net.Listen("tcp", "127.0.0.1:8080")
	if err != nil {
		panic(err)
	}

	// 死循环
	for {
		// 接收客户端建立连接
		conn, err := listen.Accept()
		if err != nil {
			fmt.Println(err)
			continue
		}
		// goroutinue处理
		go process(conn)
	}
}
```

# TCP客户端处理流程

```go
func main(){
	conn, err := net.Dial("tcp", "127.0.0.1:8080")
	if err != nil {
		fmt.Println()
	}
}
```