# 使用场景
1. 当有多个构造参数的时候
# 简单实现
```java
public class Computer {
    // 必需参数
    private final String cpu;
    private final String ram;
    
    // 可选参数
    private final String storage;
    private final String gpu;
    private final boolean bluetooth;
    
    // 私有构造器，只能通过Builder创建
    private Computer(Builder builder) {
        this.cpu = builder.cpu;
        this.ram = builder.ram;
        this.storage = builder.storage;
        this.gpu = builder.gpu;
        this.bluetooth = builder.bluetooth;
    }
    
    // Builder 静态内部类
    public static class Builder {
        // 必需参数（final）
        private final String cpu;
        private final String ram;
        
        // 可选参数（带默认值）
        private String storage = "512GB SSD";
        private String gpu = "Integrated";
        private boolean bluetooth = false;
        
        // Builder构造器（必需参数）
        public Builder(String cpu, String ram) {
            this.cpu = cpu;
            this.ram = ram;
        }
        
        // 设置可选参数的方法（返回Builder本身）
        public Builder storage(String storage) {
            this.storage = storage;
            return this;
        }
        
        public Builder gpu(String gpu) {
            this.gpu = gpu;
            return this;
        }
        
        public Builder bluetooth(boolean enabled) {
            this.bluetooth = enabled;
            return this;
        }
        
        // 构建最终对象
        public Computer build() {
            return new Computer(this);
        }
    }
}

// 创建计算机对象
Computer gamingPC = new Computer.Builder("Intel i9", "32GB DDR5")
        .storage("2TB NVMe SSD")
        .gpu("RTX 4090")
        .bluetooth(true)
        .build();
```
1. 私有化构造器，只能通过内部Builder类进行赋值
2. 共有内部静态builder类
	1. 内部set函数返回this对象
	2. 最终用build函数返回外部类对象
	3. 可以不用创建外部类就直接创建内部类

# 类层次结构Builder类
```java
public abstract class Animal {
    private final String name;
    private final int age;
    
    protected Animal(AbstractBuilder<?> builder) {
        this.name = builder.name;
        this.age = builder.age;
    }
    
    // 抽象Builder
    public abstract static class AbstractBuilder<T extends AbstractBuilder<T>> {
        private String name;
        private int age;
        
        public T name(String name) {
            this.name = name;
            return self();
        }
        
        public T age(int age) {
            this.age = age;
            return self();
        }
        
        protected abstract T self();
        public abstract Animal build();
    }
}

// 具体子类
public class Dog extends Animal {
    private final String breed;
    
    private Dog(Builder builder) {
        super(builder);
        this.breed = builder.breed;
    }
    
    public static class Builder extends Animal.AbstractBuilder<Builder> {
        private String breed;
        
        public Builder breed(String breed) {
            this.breed = breed;
            return this;
        }
        
        @Override
        protected Builder self() {
            return this;
        }
        
        @Override
        public Dog build() {
            return new Dog(this);
        }
    }
}

// 使用
Dog golden = new Dog.Builder()
        .name("Buddy")
        .age(3)
        .breed("Golden Retriever")
        .build();
```
## 抽象父类
1. 私有构造函数
2. 共有静态抽象builder
3. 共有静态抽象器利用泛型进行类型限制
	1. `T extends AbstractBuilder<t>`：T必须是AbstractBuilder的子类
4. 由于抽象builder有共有的set函数，但是抽象类不能实例化，没有this，所以必须定义一个self函数
5. 同时抽象build函数
	1. 子类实现build函数的时候可以替换返回函数的类型为子类类型
## 具体子类
1. 私有化构造函数，用内部builder类进行赋值，*同时调用super函数对父类进行初始化*
2. 静态具体builder必须继承抽象builder，泛型参数类型为具体builder
3. 重写build函数的时候，返回类型替换为具体子类