# 优点
1. 有名字
2. 不必每次调用的时候都创建一个对象
3. 可以返回原返回类型的任何子类对象
4. 可以根据参数返回不同的对象
5. 方法返回的对象所属的类可以不存在

# 静态工场方法的简单实现
```java
public class Product {
    private final String name;
    
    // 1. 私有化构造器
    private Product(String name) {
        this.name = name;
    }
    
    // 2. 静态工厂方法
    public static Product create(String name) {
        return new Product(name);
    }
    
    public String getName() {
        return name;
    }
}

// 使用示例
Product p = Product.create("Phone"); // 代替 new Product("Phone")
```
1. 私有化构造器
2. 静态工场方法

# 使用对象缓存的静态工场
```java
public class Logger {
    private static final Map<String, Logger> instances = new HashMap<>();
    private final String name;
    
    private Logger(String name) {
        this.name = name;
    }
    
    // 带缓存的静态工厂
    public static Logger getInstance(String name) {
        return instances.computeIfAbsent(name, Logger::new);
    }
}

// 使用示例
Logger log1 = Logger.getInstance("System");
Logger log2 = Logger.getInstance("System"); // 返回同一对象
```
1. 用Map当作缓存容器
2. 如果存在直接返回，不过不存在就进行构造
	1. `computeIfAbsent`函数就是这个作用
	2. `Logger::new`是java中的方法引用等价于lambda`name -> new Logger(name)`

# 泛型单例工场
创建一个单一可重用实例，该实例可以适配多种类型
1. 定义`Creator泛型接口`需要实现create函数
2. DEFAUTL_CREATOR类型得用`Creator<?>`修饰，
```java
public class ObjectCreator {
    // 单例实例（适配所有类型）
    private static final Creator<?> DEFAULT_CREATOR = new Creator<Object>() {
        @Override
        public Object create() {
            try {
                return Object.class.newInstance();
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        }
    };

    // 类型安全访问
    @SuppressWarnings("unchecked")
    public static <T> Creator<T> getCreator() {
        return (Creator<T>) DEFAULT_CREATOR;
    }

    // 带类型的创建器接口
    public interface Creator<T> {
        T create();
    }
}
```