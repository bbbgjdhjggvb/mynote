 # 泛型函数
```java
public <T> T foo(T arg0){

}

foo<Integer>(0);
```
1. 参数列表在修饰符和返回类型之间

# 泛型类
```java
public class Box<T>{  
    private T t;  
       public void set(T t) {  
            this.t= t;  
       }  
    public T get() {  
             return t;  
       }  
}
```

# 泛型继承

```java
class Box<T> { /* ... */ }

Box<Number> numberBox = new Box<>();
Box<Integer> integerBox = new Box<>();

numberBox.add(new Iteger(10))
numberBox.add(new Double(1.1))

// 编译错误：不兼容的类型
numberBox = integerBox; // ❌
integerBox = numberBox; // ❌
```

# 泛型类型擦除
泛型代码在编译时，会移除所有类型信息
1. 无界类型参数替换为Object
```java
// 编译前
List<T> list = new ArrayList<>();

// 擦除后
List list = new ArrayList(); // 原始类型
```
2. 有界类型替换为边界类型
```java
// 编译前
class NumberBox<T extends Number> {
    T value;
}

// 擦除后
class NumberBox {
    Number value; // T 被擦除为 Number
}
```

## 类型擦除带来的限制
1. 无法实例化泛型参数类型
```java
public class Container<T> {
    private T instance = new T(); // ❌ 编译错误
}
```
2. 无法创建泛型数组
```java
// 编译错误：创建泛型数组
T[] array = new T[10]; // ❌

// 部分解决方案（需类型转换）
T[] array = (T[]) new Object[10]; // 警告：未经检查的转换
```
3. 静态成员共享
```java
class Box<T> {
    static int count; // 所有 Box 实例共享同一个 count
    // 因为经过类型擦除后只有 Box 类
}
```
4. 方法签名冲突
```java
// 编译错误：两个方法擦除后签名相同
void process(List<String> list) { ... }
void process(List<Integer> list) { ... } // ❌
```

## 克服类型擦除的技巧
### 泛型数组
1. 利用反射创建泛型数组
```java
public class TypeAwareContainer<T> {
    private final Class<T> type;
    private T value;
    
    public TypeAwareContainer(Class<T> type) {
        this.type = type;
    }
    
    public T createInstance() throws Exception {
        return type.newInstance(); // 通过反射创建
    }
}

// 使用
TypeAwareContainer<String> container = 
    new TypeAwareContainer<>(String.class);
```
2. 使用Object[]数组，然后单个元素转换为T
	1. 需要用到`@SuppressWarnings("unchecked")`
```java
public class GenericArray<T> {
    private final Object[] array;
    
    public GenericArray(int size) {
        array = new Object[size];
    }
    
    @SuppressWarnings("unchecked")
    public T get(int index) {
        return (T) array[index]; // 安全转换（由开发者保证类型安全）
    }
    
    public void set(int index, T element) {
        array[index] = element;
    }
}

// 使用示例
GenericArray<String> strArray = new GenericArray<>(5);
strArray.set(0, "Java");
String s = strArray.get(0); // 安全
```

# 泛型类的递归限制
```java
<T extends SomeInterface<T>>
```

# 生产者和消费者
java中生产者和消费者是一种对数据流向的表示，通过`? extends`和`? super`来是实现
## 生产者：从结构中读取数据
1. 函数参数是结构，从结构中读的东西必须是子类，存放在父类中
```java
public static double sum(List<? extends Number> numbers) {
    double total = 0.0;
    for (Number num : numbers) { // 安全读取
        total += num.doubleValue();
    }
    return total;
}
```

## 消费者：往结构中存放数据
1. 函数参数是结构，存东西的类型必须是父类
```java
 public void popAll(Collection < ? super E > dst) {
        while (!isEmpty())
            dst.add(pop());
 }
```

# 提高泛型灵活度，满足继承调用的使用要求
下面的两个函数
```java
// 版本1：严格类型约束
public static <T extends Comparable<T>> T max(List<T> list)

// 版本2：灵活类型约束
public static <T extends Comparable<? super T>> T max(List<? extends T> list)
```
当调用max函数处理的是Dog类型的时候，max函数在编译时认为T是DOG，并且限制了DOG实现Comparable\<DOG\>接口，但是DOG没有实现自己的Comparable接口，因为DOG想要复用Animal的接口。所以限制得改为T或者T的父类必须实现Comparable接口，参数通配符的作用是允许处理DOG的子类。
```java
class Animal implements Comparable<Animal> {
    private int weight;
    
    public Animal(int weight) {
        this.weight = weight;
    }
    
    @Override
    public int compareTo(Animal other) {
        return Integer.compare(this.weight, other.weight);
    }
}

class Dog extends Animal {
    public Dog(int weight) {
        super(weight);
    }
}

List<Dog> dogs = List.of(new Dog(10), new Dog(20));

// 编译错误：版本1无法处理
Dog maxDog = max(dogs);
```

# 类型安全的异构容器
运行在一个容器中安全存放不同类型的数据和检索不同类型的数据

传统容器的局限
```java
// 传统容器：单一类型
Map<String, Integer> scores = new HashMap<>();
scores.put("Alice", 90); // ✅
scores.put(42, "Bob");   // ❌ 编译错误 - 类型不匹配
```

异构容器的突破
```java
// 异构容器：多类型安全存储
Favorites favorites = new Favorites();
favorites.put(String.class, "Java");
favorites.put(Integer.class, 42);
favorites.put(Class.class, Favorites.class);

// 安全检索
String lang = favorites.get(String.class); // "Java"
Integer num = favorites.get(Integer.class); // 42
```

## 实现原理
```java
import java.util.*;

public class Favorites {
    // 关键：使用Class对象作为类型安全键
    private Map<Class<?>, Object> favorites = new HashMap<>();
    
    // 类型安全写入
    public <T> void put(Class<T> type, T instance) {
        favorites.put(Objects.requireNonNull(type), 
                     type.cast(instance)); // 类型校验
    }
    
    // 类型安全读取
    public <T> T get(Class<T> type) {
        return type.cast(favorites.get(type)); // 动态转换
    }
}
```