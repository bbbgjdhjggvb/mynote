1. g++ -Og -o prog main.cpp
	1. -Og选项表示优化
	2. 从得到的程序性能考虑，最好使用-O1和-O2
2.  g++ -Og -S main.cpp会生成汇编文件.s
3. g++ -Og -c main.s会生成二进制.o文件
### 反汇编工具objdump
1. objdump -d main.cpp会在终端中打印出内容
### 静态库
#### 静态库的作用
如果将300个函数写在一个源文件里面，编译出foo.o文件，将foo.o文件和main.o文件进行连接得到可执行文件a.out，但是我们在main.o中只用了一个函数，这样的过程将会带来几个问题：
1. 磁盘空间浪费：需要将磁盘中的foo.o复制一份和main.o合并
2. 内存空间浪费：将会把300个函数需要的东西加载到内存中
3. 不方便管理：重写一个函数就要把foo.c函数重新编译一遍
静态库就是一个函数写一个.c文件，然后编译出.o文件，再把许多个.o文件合并在一起形成一个库，这个库以.a结尾，如果main.c只使用到一个函数，只需要合并相应函数的.o文件就可以了。
静态表示：链接器构建一个可执行文件的完全体，然后加载到内存中，在加载时无需更进一步链接

#### 使用静态库
##### g++编译器
目录结构如下：
![[Pasted image 20240816214309.png]]
然后使用指令`g++ -static -o main.exe .\src\main.o .\lib\lib\libmymath.a`
1. 必须是main.o不能是main.cpp
2. 该指令等价于`g++ -static -o main.exe src\main.o -Llib所在位置 -lmymathlib库`
	1. -L和-l一定要在最后
链接静态库和主目标文件有顺序要求，因为链接器的算法要求。
1. 链接器会维护三个集合，E：目标文件集合(.o)，D：解析好的符号，U：未解析的符号（引用其他文件里面的函数）。
2. 根据命令行依次读取文件：如果是目标文件(.o)就加入E，更改U和D，如果是存档文件(.a)就匹配U中元素和存档文件中的成员m(.o)中定义的符号，如果匹配到就将m加入E，修改D和U
3. 所有文件读取过后如果U非空就会报错：`undefined reference to xxx`

### 共享库

静态库需要将调用的函数的代码整合到目标文件中生成可执行文件，对于多个目标程序都需要用到库中函数的情况，将会复制多份代码，使得内存浪费，动态库就是直接将需要用到的库中函数加载到内存中，让可执行文件进行动态链接，这样就只需要加载一份库函数。
动态库文件的名字以.so为后缀，一个库只能有一个.so文件

#### 在应用程序被加载后执行前进行链接
1. 创建可执行文件时，执行一些静态链接，然后在程序加载时动态完成链接过程
	1. 没有libxxx.so的代码和数据节被复制到可执行文件中
`g++ -share -fpic -o libxxx.so 源文件`：生成libxxx.so文件
`g++ -o main.exe main.cpp libxxx.so`：生成可执行文件

### 在应用程序中加载和链接共享库


### 设置栈的大小
使用指令`g++ -o main main.cpp -Wl,--stack,83688608`
1. -WI选项告诉g++编译器，接下来的内容传递给链接器，选项之间用逗号隔开，相当于`--stack 83688608`
2. `-Wl,--stack,83688608`是一个选项
3. 数字的单位是字节