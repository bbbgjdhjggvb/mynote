set是一种有序的、不允许重复元素的容器，底层基于红黑树实现
# 初始化
```c++
#include <set>

// 默认构造函数
set<int> s;  

// 列表初始化
set<int> s{1,2,3};

// 范围初始化，利用其他容器的迭代器进行范围初始化
vector<int> v{1,2,3}
set<int> s(v.begin(), v.end())
```

# 插入元素
- 返回`pair<iterator, bool>`
```c++
auto res1 = s.insert(2); // 成功，res1.second = true
auto res2 = s.insert(2); // 失败，res1.second = false

// 插入多个元素
auto res1 = s.insert({1,2,3})

// 范围迭代器插入
vector<int> v{1,2,3}
auto res1 = s.insert(v.begin(), v.end())
```

# 删除元素
- 如果成功返回1，失败返回0
```c++
// 指定元素删除
int n = s.erase(3)

// 先用find，再根据迭代器删除
auto it = s.find(3)
if (it != s.end()){
	s.erase(it)
}

// 利用迭代器范围删除
auto start = s.find(4)
auto end = s.find(6)
s.erase(start, end)
```

# 查找元素
```c++
// 下面操作的时间复杂度都是log(n)
// 返回迭代器，找不到返回s.end()
auto it = s.find(1);

// 利用count判断元素是否存在
int n = s.count(1

// 返回第一个不小于val的迭代器
auto it = s.lower_bound(val)

// 返回第一个大于val的迭代器
auto it = s.upper_bound(val)
```

# 遍历
- 支持迭代器遍历和范围查询
- set集合中对象是const，不能通过迭代器直接修改
```c++
for (auto it = s.begin(); it != s.end(); it++){
	cout << *it <<endl;
}

for (int val : s){
	cout << val << endl;
}
```
# 其他常用操作
```c++
s.size()
s.empty()
s.clear()
s.swap(s2)
```

# 利用函数模版对set自定义排序

